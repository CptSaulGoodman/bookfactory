{% extends "base.html" %}

{% block title %}{{ _('writing_chapter') }} {{ chapter.chapter_number }}{% endblock %}

{% block content %}
<div class="chapter-writing-container">
    <header class="chapter-header">
        <h1 class="chapter-title">{{ chapter.title }}</h1>
        <h2 class="chapter-subtitle">{{ book.title }} - {{ _('chapter') }} {{ chapter.chapter_number }}</h2>
        <p class="chapter-synopsis">{{ chapter.synopsis }}</p>
    </header>

    <!-- This div will be replaced by the streaming content -->
    <div id="writing-interface">
        
        <!-- This is where the streamed content will appear. -->
        <div id="chapter-content" class="chapter-content-container">
            {% if formatted_content %}{{ formatted_content | safe }}{% endif %}
        </div>

        <!-- This form will be hidden after submission -->
        <div id="form-container">
            {% if chapter.status == 'draft' %}
                <form id="chapter-form" class="chapter-form">
                    <input type="hidden" name="part" value="1">
                    <div class="form-group">
                        <label for="user_directives">{{ _('chapter_directives_prompt') }}</label>
                        <textarea id="user_directives" name="user_directives" class="form-control" rows="5" 
                                  placeholder="{{ _('chapter_directives_placeholder') }}"></textarea>
                    </div>
                    <button type="submit" class="btn btn-primary">{{ _('start_writing') }}</button>
                </form>
            {% elif chapter.status == 'part1_completed' %}
                <form id="chapter-form" class="chapter-form">
                    <input type="hidden" name="part" value="2">
                    <div class="form-group">
                        <label for="user_directives">{{ _('chapter_continue_prompt') }}</label>
                        <textarea id="user_directives" name="user_directives" class="form-control" rows="5" 
                                  placeholder="{{ _('chapter_continue_placeholder') }}"></textarea>
                    </div>
                    <button type="submit" class="btn btn-primary">{{ _('continue_writing') }}</button>
                </form>
            {% elif chapter.status == 'completed' %}
            <div class="chapter-navigation">
                {% if chapter.chapter_number > 1 %}
                    <a href="/book/{{ book.id }}/chapter/{{ chapter.chapter_number - 1 }}" class="btn btn-secondary">{{ _('previous_chapter') }}</a>
                {% endif %}
                
                <a href="/book/{{ book.id }}" class="btn btn-secondary">{{ _('back_to_overview') }}</a>
                
                {% if chapter.chapter_number < book.chapters|length %}
                    <a href="/book/{{ book.id }}/chapter/{{ chapter.chapter_number + 1 }}" class="btn btn-secondary">{{ _('next_chapter') }}</a>
                {% endif %}
            </div>
            {% endif %}
        </div>

        <!-- Spinner shown during the request -->
        <div class="writing-status htmx-indicator">
             <div class="spinner"></div>
             <p>{{ _("writing_in_progress") }}</p>
        </div>
    </div>
</div>

<script>
    // Simple markdown parser for paragraphs, italic, and bold
    function parseMarkdown(text) {
        // Split into paragraphs (single newlines)
        const paragraphs = text.split('\n');
        
        return paragraphs.map(paragraph => {
            if (!paragraph.trim()) return '';
            
            // Convert **bold** to <strong>bold</strong>
            let parsed = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic* to <em>italic</em>
            parsed = parsed.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Wrap in paragraph tags
            return `<p>${parsed}</p>`;
        }).join('');
    }

    // Auto-scroll functionality
    let autoScroll = true;
    let userScrolled = false;
    const contentDiv = document.getElementById('chapter-content');
    const container = document.getElementById('writing-interface');

    // Check if user is at the bottom
    function isAtBottom() {
        return container.scrollTop + container.clientHeight >= container.scrollHeight - 10;
    }

    // Auto-scroll to bottom
    function scrollToBottom() {
        if (autoScroll) {
            container.scrollTop = container.scrollHeight;
        }
    }

    // Handle user scroll events
    container.addEventListener('scroll', function() {
        if (userScrolled) {
            // If user scrolls to bottom, re-enable auto-scroll
            if (isAtBottom()) {
                autoScroll = true;
                userScrolled = false;
            }
        } else {
            // If user scrolls up, disable auto-scroll
            if (!isAtBottom()) {
                autoScroll = false;
                userScrolled = true;
            }
        }
    });

    document.getElementById('chapter-form').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const formData = new FormData(this);
        const part = formData.get('part');
        const userDirectives = formData.get('user_directives');
        
        // Clear the content area
        document.getElementById('chapter-content').innerHTML = '';
        
        // Reset scroll state
        autoScroll = true;
        userScrolled = false;
        
        // Show the spinner
        document.querySelector('.writing-status').style.display = 'block';
        
        // Create SSE connection
        const eventSource = new EventSource(`/book/{{ book.id }}/chapter/{{ chapter.id }}/generate-stream?part=${part}&user_directives=${encodeURIComponent(userDirectives)}`);
        
        let accumulatedText = '';
        
        eventSource.onmessage = function(event) {
            const contentDiv = document.getElementById('chapter-content');
            accumulatedText += event.data;
            
            // Parse markdown and update content
            const parsedHtml = parseMarkdown(accumulatedText);
            contentDiv.innerHTML = parsedHtml;
            
            // Auto-scroll to bottom
            scrollToBottom();
        };
        
        eventSource.addEventListener('complete', function(event) {
            eventSource.close();
            //setTimeout(() => { window.location.reload(); }, 500);
        });
        
        eventSource.addEventListener('error', function(event) {
            eventSource.close();
            document.getElementById('chapter-content').innerHTML = '<p class="error">An error occurred during streaming.</p>';
        });
    });

    // Hide the form once the request begins
    document.body.addEventListener('htmx:beforeRequest', function(event) {
        const formContainer = document.getElementById('form-container');
        if (formContainer) {
            //formContainer.style.display = 'none';
        }
    });
</script>
{% endblock %}