{% extends "base.html" %}

{% block title %}{{ _('writing_chapter') }} {{ chapter.chapter_number }}{% endblock %}

{% block content %}
<div class="chapter-writing-container">
    <header class="chapter-header">
        <h1 class="chapter-title">{{ chapter.title }}</h1>
        <h2 class="chapter-subtitle">{{ book.title }} - {{ _('chapter') }} {{ chapter.chapter_number }}</h2>
        <p class="chapter-synopsis">{{ chapter.synopsis }}</p>
    </header>

    <!-- This div will be replaced by the streaming content -->
    <div id="writing-interface">
        
        <!-- This is where the streamed content will appear. -->
        <div id="chapter-content" class="chapter-content-container">
            {% if formatted_content %}{{ formatted_content | safe }}{% endif %}
        </div>



        <!-- This form will be hidden after submission -->
        <div id="form-container">
            {% if chapter.status != 'completed' %}
            <form id="chapter-form" class="chapter-form">
                <input type="hidden" name="part" value="{% if chapter.status == 'draft' %}1{% elif chapter.status == 'part1_completed' %}2{% endif %}">
                <div class="form-group">
                    <label for="user_directives">{% if chapter.status == 'draft' %}{{ _('chapter_directives_prompt') }}{% elif chapter.status == 'part1_completed' %}{{ _('chapter_continue_prompt') }}{% endif %}</label>
                    <textarea id="user_directives" name="user_directives" class="form-control" rows="5" 
                                    placeholder="{% if chapter.status == 'draft' %}{{ _('chapter_directives_placeholder') }}{% elif chapter.status == 'part1_completed' %}{{ _('chapter_continue_placeholder') }}{% endif %}"></textarea>
                </div>

                <div class="d-flex justify-content-between">
                    <div style="flex: 1;">
                    {% set previous_chapter_id = previous_chapter_id if previous_chapter_id else none %}
                    {% set next_chapter_id = next_chapter_id if next_chapter_id else none %}
                    {% include "_chapter_navigation.html" with context %}
                    </div>
                    <div style="flex: 2; text-align: right;">
                        <button type="submit" class="btn btn-primary">{{ _('start_writing') if chapter.status == 'draft' else _('continue_writing') }}</button>
                    </div>
                </div>
            </form>
            {% else %}
                {% set previous_chapter_id = previous_chapter_id if previous_chapter_id else none %}
                {% set next_chapter_id = next_chapter_id if next_chapter_id else none %}
                {% include "_chapter_navigation.html" with context %}
            {% endif %}
        </div>

        <!-- Spinner shown during the request -->
        <div class="writing-status htmx-indicator">
             <div class="spinner"></div>
             <p>{{ _("writing_in_progress") }}</p>
        </div>
    </div>
</div>

<script>
    // Simple markdown parser for paragraphs, italic, and bold
    function parseMarkdown(text) {
        // Split into paragraphs (single newlines)
        const paragraphs = text.split('\n');
        
        return paragraphs.map(paragraph => {
            if (!paragraph.trim()) return '';
            
            // Convert **bold** to <strong>bold</strong>
            let parsed = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic* to <em>italic</em>
            parsed = parsed.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Wrap in paragraph tags
            return `<p>${parsed}</p>`;
        }).join('');
    }

    // Auto-scroll functionality with buffer
    let autoScroll = true;
    let userScrolled = false;
    let lastScrollPosition = 0;
    let isProgrammaticScroll = false; // Flag to prevent auto-scroll from triggering scroll events
    const contentDiv = document.getElementById('chapter-content');
    const BUFFER_ZONE = 100; // pixels from bottom to consider "at bottom"

    // Check if user is at the bottom with buffer zone
    function isAtBottom() {
        const scrollPosition = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        const distanceFromBottom = documentHeight - (scrollPosition + windowHeight);
        
        return distanceFromBottom <= BUFFER_ZONE;
    }

    // Auto-scroll to bottom of the page
    function scrollToBottom() {
        if (autoScroll) {
            isProgrammaticScroll = true;
            window.scrollTo({
                top: document.documentElement.scrollHeight,
                behavior: 'smooth'
            });
            // Reset the flag after a short delay
            setTimeout(() => {
                isProgrammaticScroll = false;
            }, 100);
        }
    }

    // Handle user scroll events on the window
    window.addEventListener('scroll', function() {
        // Ignore programmatic scrolls
        if (isProgrammaticScroll) return;

        const currentScrollPosition = window.scrollY;
        const scrollDistance = Math.abs(currentScrollPosition - lastScrollPosition);
        lastScrollPosition = currentScrollPosition;

        // Only consider it a user scroll if they moved more than a small threshold
        if (scrollDistance < 3) return;

        // If user scrolls away from bottom, disable auto-scroll
        if (!isAtBottom()) {
            autoScroll = false;
            userScrolled = true;
        } else {
            // If user scrolls to bottom area, re-enable auto-scroll
            autoScroll = true;
            userScrolled = false;
        }
    });

    document.getElementById('chapter-form').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const formData = new FormData(this);
        const part = formData.get('part');
        const userDirectives = formData.get('user_directives');
        
        // Clear the content area
        document.getElementById('chapter-content').innerHTML = '';
        
        // Don't reset scroll state - maintain user's preference
        // autoScroll = true;
        // userScrolled = false;
        lastScrollPosition = window.scrollY;
        
        // Show the spinner
        document.querySelector('.writing-status').style.display = 'block';
        
        // Create SSE connection
        const eventSource = new EventSource(`/book/{{ book.id }}/chapter/{{ chapter.id }}/generate-stream?part=${part}&user_directives=${encodeURIComponent(userDirectives)}`);
        
        let accumulatedText = '';
        
        eventSource.onmessage = function(event) {
            const contentDiv = document.getElementById('chapter-content');
            accumulatedText += event.data;
            
            // Parse markdown and update content
            const parsedHtml = parseMarkdown(accumulatedText);
            contentDiv.innerHTML = parsedHtml;
            
            // Auto-scroll to bottom only if user hasn't scrolled away
            scrollToBottom();
        };
        
        eventSource.addEventListener('complete', function(event) {
            eventSource.close();
            //setTimeout(() => { window.location.reload(); }, 500);
        });
        
        eventSource.addEventListener('error', function(event) {
            eventSource.close();
            document.getElementById('chapter-content').innerHTML = '<p class="error">An error occurred during streaming.</p>';
        });
    });

    // Hide the form once the request begins
    document.body.addEventListener('htmx:beforeRequest', function(event) {
        const formContainer = document.getElementById('form-container');
        if (formContainer) {
            //formContainer.style.display = 'none';
        }
    });
</script>
{% endblock %}